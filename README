Advika Deodhar 6pm Lab 

--------------------------------------------------------------------------------------------------------------


NEEED TO IMPLEMENT STILL:
6) If the sender is not able to open the from-file, rcopy should print out the error message: Error: file <fromfilename> not found. rcopy should then exit.
7) If the receiver cannot open the to-file, rcopy should print out the error message: Error on open of output
file: <to-filename>. 




Readmeeee again woooooo!!! Time to read the spec

Writing two programs, RCOPY and SERVER

RCOPY: 
- takes in a src filename, dest filename, window size, buffer size, error-rate, remote-machine, remote-port.  
- window size = how many packets in the window
- buffer size = number of bytes to read from disk and send in each packet
- error-rate = percent of packets that are in error (I DONT GET THIS)
- remote-machine = the machine that runs the server
- remote-port = server port number
- if it cant open the dest file print out error
- you ask the server if it has the src filename
- if it does, the server will send that file to the client 
- the client will downlaod info from the source and print that out to the dest file
- will need to create an application PDU and send the data in chunks 

SERVER:
- takes in the window-size, buffer-size, and filename from rcopy (make a struct?)
- the server takes in an optional port number to use (if not given, use 0 to pass to bind())
- can only terminate with ^c
- should process multiple clients at the same time (need to do threading??)
- if there is an error opening the file, send an error packet back to the client
- 

ERRORS:
- for error checking use the sendToErr() function

WINDOW:
- need a separate library for the windowing window.c window.h
- can only use 5 global variables in this, and those can't be used anywhere else 
- both the server and client use this structure 
    - the server will use it to keep track of what packets have been sent but not acknowledged yet
    - the client uses it to keep track of packets that come in out of order (it will reorder before printing to output file)
- make this by mallocking for an array (make sure you free and valgrind to check)
- make it a circular buffer
- must only edit the buffer through the windowing library functions I write (cant access ideces directly)

SELECTIVE REJECT:
- this protocol works by only resending the packet that went missing
- if a packet is missing, client sends SREJ message to server
- server resends the missing packet
- client sends a RR to say that it is ready to continue receiving

UDP CONNECTION:


FILENAME EXCHANGE RCOPY: 

- Send file state: 
    - create a socket to send on 
    - make the filename sending PDU (4 byte sequence number)(2 byte checksum)(1 byte flag)(1400 byte payload)
    - choosing arbitrarily to have it be filename, buffer-size, then window-size
        - need to calculate the checksum
            - zero it out upon construction
            - call checksum on whole packet
            - memcpy the packet back out 
        - sequence number is in network order (choose some value?)
        - flag = 8 
        - verify that the packet is being created properly
    - use sendToErr() to send this packet
    - if the timer expires or data is received, then stay in this state 
        - close the socket
        - open a new socket
        - send filename on the new scoket 
        - increment the counter
        - re-start the poll(1) CLARIFY
    - if time expires and count is greater than 9
        - move to DONE state
    - if bad file is received 
        - move to DONE state
    - if file is OK
        - move to fileOK state

- File Ok State:
    - open the output file
    - if opening output file fails move to DONE state
    - if it works then move to the RECVDATA state

- DONE State:
    - print out an error and terminate process

- RECEIVE Data State: 
    - do nothing here for now, will implement this when we get into the sliding window? 
    - need to do sliding window for client and server?

FILENAME EXCHANGE SERVER:
- GET FILENAME State:
    - fork off a child server process and pass it the info of the client
    - get the filename packet
        - get the client port number and IP address from doing the recvFrom
    - open the file
    - close the main server socket
    - if opening the file doest work, move to DONE state
    - if the file is ok, open a new socket and send a filename ack packet and move to SEND DATA state
- DONE State:
    - terminate the server (no printing of error)
- SEND DATA State:
    - send the data packet
    - set count to 0
    - call poll
    - move to WAIT ON ACK state
    - if the EOF flag is read set the counter to 0 and move to the WAIT ON EOF ack
- WAIT ON ACK State:
    - if it times out, and the count is > 9 move to the done state 
    - if the timer goes out and the count is < 9 resend the data, count ++, poll
    - if ack is recieved, move back to the SEND DATA state to send the next packet
- WAIT ON EOF ACK: 
    - if the timer expires, resend the EOF packet, count++ and restart the poll
    - if the timer expires and the count > 9, close the file, close the socket, and move to the DONE state
    - if the EOF ack is received, close the file and close the socket and move to DONE state


SERVER AGAIN:
- Main:
    - wait for the filename request
    - recvFrom the pdu
    - extract the filename, the window size and buffer size 
    - calculate the checksum (if bad then keep waiting for packet)
    - pass the client info to the get filename state 
- FSM: 
- GET_FILENAME:
    - fork off a server child
        - immedately send a hello talk to here packet to the client (flag = 33) 
    - parent goes back to waiting for new clients
    - child process will try and open the filename
    - if it works, then calcualte the right valid ack packet and send that back to client 
        - move to SEND_DATA state
    - if it doesnt work then send the error packet back
        - move to the DONE state
    - thats it for now, the rest of the states will be implemented with sliding window



    couple issues:
    - the filename is not being read out right
    - moving to the DONE state and ending is not happening it keeps going back up to the top of something and continuing 
    
    Windowing:
    - window size (W) = how many unacknowledged frams we can have (how big the buffer is on the sender)
    - lower edge (L) = the lowest edge that has not been acknowledged
    - upper edge (U) = one higher than the highest frame you can send 
    - current = the frame I am sending 

    - when current = upper, the window is closed
    - when this happens, stop sending until an RR arrives
    - when the RR arrives, L = RR number and U = L + window size
    - window buffer must be implemneted as a 2D array on rcopy and server
    - the window buffer can't be bigger than the window size 
    - malloc() for them at the start of the file transfer
    - must be implemented as a circular queue that is indexed by sequence number
    - the window index = sequence number % window size
    - on the server, cerate this buffer only after forking a child 
    - on the sender, this is used for windowing
    - on the reciever its just a buffer to store data when packets are lost 
    - all accessor functions must be defined in separate c file
    - can only have a max of 5 global variables in these windowing files
    - those global variables cannot be accessed by the server or rcopy programs
    - 

    - isn't the max packet size 1407 according to the spec or is packet size something different
    - also shouldnt the max window size be adjusted based on the command line arguments
    - so the window initializing function should be passed in the window size and the buffer size because the server and client both know that beforehand? 
    - can each slot in the buffer only hold one packet? 
    - can I implement 2D arrays as structs? how are 2D arrays implemented in C?
    - would I ever need a helper function to remove a packet from the window? 
    - in the init function wouldnt I have to malloc for my 2D array?
    - why would inserting it in the window mean I have to memcpy isnt it a regular array?
    - for moving the window forward, dont I have to reset the lower edge to the RR then make the upper edge L + window size?
    - 


    WINDOWING CASES TO TEST FOR:
    - window size is 3, 



RCOPY DATA GETTING STATE MACHINE:
3 states:

IN ORDER: 
- when the receiver gets the correct in order packets
- stays in this state until a packet greater than expected arrives
- highest counter = expected packet
- each time you receive you do expected ++
- then send an RR packet back to the sender for the expected 
- move to buffering state if recieved > expected 
    - need to send a SREJ packet for the expected
    - buffer the PDU that you receive 
    - set the highest = last received sequence number

BUFFERING:
- go here when the packet received is greater than the expected packet
- stay here while I receive > expected 
- keep buffering what you receive 
- highest = received 
- highest indcates what is the largest thing in the buffer
- receive expected and move to flushing state

FLUSHING:
- when you receive the expected packet
- write that one to disc
- increment expected
- flush the buffer
- implement as a while loop
    - while the sequence number = the buffer 
- when done with flushing, go back to buffering or go to in order
- move out of this state when while loop is over


